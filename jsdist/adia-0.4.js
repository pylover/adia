__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1628460651353, "adia.renderingplans": [".py", "import abc\n\nfrom .lazyattr import LazyAttribute\nfrom .constants import RIGHT,LEFT\n\n\nclass RenderingPlan:\n\n pass\n \n \nclass ModulePlan(RenderingPlan):\n col=0\n row=0\n \n def __init__(self,module,lpad=0,rpad=0):\n  self.module=module\n  self.lpad=lpad\n  self.rpad=rpad\n  \n def __repr__(self):\n  return f'ModulePlan: {self.title}'\n  \n @LazyAttribute\n def box_hpadding(self):\n  return 1,int(not (len(self.title)%2))+1\n  \n @LazyAttribute\n def boxlen(self):\n  lp,rp=self.box_hpadding\n  return len(self.title)+lp+rp+2\n  \n @LazyAttribute\n def title(self):\n  return self.module.title\n  \n @property\n def middlecol(self):\n  return self.col+self.boxlen //2\n  \n def drawbox(self,renderer,col=None ,row=None ):\n  if col:\n   self.col=col\n   \n  if row:\n   self.row=row\n   \n  renderer.canvas.draw_textbox(\n  self.col,self.row,self.title,hpadding=(self.box_hpadding))\n  \n def drawpipe(self,renderer,row):\n  renderer.canvas.set_char(self.middlecol,row,'|')\n  \n  \nclass ItemPlan(RenderingPlan,metaclass=abc.ABCMeta):\n char='!'\n repr_symbol='!!!!'\n direction=RIGHT\n length=0\n start=0\n end=0\n \n def __init__(self,item,direction,level):\n  self.item=item\n  self.level=level\n  self.direction=direction\n  \n def __repr__(self):\n  return f'{self.repr_symbol} {repr(self.item)}'\n  \n @LazyAttribute\n def textwidth(self):\n  if self.text:\n   return len(self.text)\n   \n  return 0\n  \n @property\n def kind(self):\n  return self.item.kind\n  \n @property\n def text(self):\n  return self.item.text\n  \n @abc.abstractmethod\n def calc(self):\n  raise NotImplementedError()\n  \n  \nclass ItemStartPlan(ItemPlan):\n char='~'\n repr_symbol='~~~>'\n reverse=False\n selfcall=False\n \n def __init__(self,item,caller,callee,direction,level):\n  super().__init__(item,direction,level)\n  self.caller=caller\n  self.callee=callee\n  if caller is callee:\n   self.selfcall=True\n   \n def _calc_selfcall(self):\n  self.start=self.caller.middlecol\n  \n  linelen=0\n  if self.item.text:\n   linelen=len(self.item.text)\n   \n  if self.item.returntext:\n   linelen=max(len(self.item.returntext),linelen)\n   \n  self.length=linelen+6\n  self.start +=1\n  self.end=self.start+self.length\n  return 0,1,0\n  \n def _calc_otherscall(self):\n  self.start=self.caller.middlecol\n  self.end=self.callee.middlecol\n  \n  if self.start >self.end:\n   self.start,self.end=self.end,self.start\n   \n  self.start +=1\n  self.length=self.end -self.start\n  \n  return 0,1,0\n  \n def calc(self):\n  if self.selfcall:\n   return self._calc_selfcall()\n  else :\n   return self._calc_otherscall()\n   \n def draw(self,renderer,row):\n  canvas=renderer.canvas\n  \n  canvas.draw_hline(self.start,row,self.length,char=self.char)\n  if self.direction ==LEFT:\n   canvas.set_char(self.start,row,'<')\n  else :\n   canvas.set_char(self.end -1,row,'>')\n   \n  if self.text:\n   canvas.write_textline(self.start+3,row,self.text)\n   \n  if not self.selfcall:\n   return\n   \n  canvas.set_char(self.end,row,'+')\n  canvas.set_char(self.end -1,row,self.char)\n  renderer.register_repeat(self.end,'|')\n  \n  \nclass ItemEndPlan(ItemStartPlan):\n char='-'\n repr_symbol='<---'\n reverse=True\n \n @property\n def text(self):\n  return self.item.returntext\n  \n def draw(self,renderer,row):\n  super().draw(renderer,row)\n  \n  if not self.selfcall:\n   return\n   \n  renderer.unregister_repeat(self.end,'|')\n  \n  \nclass ConditionStartPlan(ItemPlan):\n char='*'\n startmodule=None\n endmodule=None\n children=None\n \n def __init__(self,item,startmodule,endmodule,level):\n  super().__init__(item,RIGHT,level)\n  self.startmodule=startmodule\n  self.endmodule=endmodule\n  \n @property\n def singlemodule(self):\n  return self.startmodule is self.endmodule\n  \n @LazyAttribute\n def text(self):\n  result=f'{self.item.kind}'\n  if self.item.text:\n   result +=f' {self.item.text}'\n   \n  return result\n  \n def _calc_singlemodule(self):\n  self.start=self.startmodule.col\n  \n  linelen=0\n  if self.item.text:\n   linelen=len(self.item.text)\n   \n  self.length=linelen+7\n  self.end=self.start+self.length\n  self.end -=1\n  return 0,3,0\n  \n def _calc_multimodule(self):\n  self.start=self.startmodule.col\n  self.end=self.endmodule.col+self.endmodule.boxlen\n  self.length=self.end -self.start\n  self.end -=1\n  return 0,3,0\n  \n def calc(self):\n  if self.startmodule is None :\n   self.start=0\n   self.length=max(10,self.textwidth+4)\n   self.end=self.length -1\n   return 0,3,0\n   \n  if self.singlemodule:\n   return self._calc_singlemodule()\n  else :\n   return self._calc_multimodule()\n   \n def draw(self,renderer,row):\n  canvas=renderer.canvas\n  \n  canvas.draw_hline(self.start,row,self.length,char=self.char)\n  \n  row +=1\n  canvas.write_textline(self.start,row,' '*self.length)\n  canvas.set_char(self.start,row,'*')\n  canvas.set_char(self.end,row,'*')\n  canvas.write_textline(self.start+2,row,self.text)\n  \n  row +=1\n  canvas.draw_hline(self.start,row,self.length,char=self.char)\n  \n  \nclass ConditionEndPlan(ConditionStartPlan):\n\n @property\n def text(self):\n  if self.kind in ('if','elif','else'):\n   return 'end if'\n   \n  return f'end {self.kind}'\n  \n  \nclass NotePlan(ItemPlan):\n char='-'\n repr_symbol='@'\n startmodule=None\n endmodule=None\n \n def __init__(self,item,startmodule,endmodule,level):\n  super().__init__(item,RIGHT,level)\n  self.startmodule=startmodule\n  self.endmodule=endmodule\n  \n @LazyAttribute\n def lines(self):\n  return self.text.splitlines()\n  \n @LazyAttribute\n def textwidth(self):\n  return max(len(x)for x in self.lines)\n  \n def calc(self):\n  self.start=self.startmodule.col\n  \n  if self.endmodule is None :\n   self.length=self.startmodule.boxlen\n  else :\n   self.length=(self.endmodule.col+self.endmodule.boxlen)-\\\n   self.start\n   \n  self.length=max(self.length,self.textwidth+4)\n  self.end=self.start+self.length\n  return 0,len(self.lines)+2,0\n  \n def draw(self,renderer,row):\n  canvas=renderer.canvas\n  \n  canvas.draw_hline(self.start,row,self.length,char=self.char)\n  \n  for linelen in self.lines:\n   row +=1\n   canvas.write_textline(self.start,row,' '*self.length)\n   canvas.write_textline(self.start+2,row,linelen)\n   canvas.set_char(self.start,row,'|')\n   canvas.set_char(self.end -1,row,'|')\n   \n  row +=1\n  canvas.draw_hline(self.start,row,self.length,char=self.char)\n", ["abc", "adia.constants", "adia.lazyattr"]], "adia.sequence": [".py", "from io import StringIO\n\nfrom .lazyattr import LazyAttribute\nfrom .container import Container\nfrom .interpreter import Interpreter,Consume,Final,FinalConsume,New,\\\nIgnore,Goto,Switch\nfrom .token import NAME,NEWLINE,EVERYTHING,RARROW,COLON,AT,HASH,EOF,\\\nDOT,DEDENT,INDENT,MULTILINE,TILDA\n\n\nclass Module:\n title=None\n type='module'\n \n def __init__(self,title):\n  self.title=title\n  \n  \nclass Item(Interpreter):\n kind=None\n args=None\n text=None\n multiline=None\n \n def __init__(self,*args,**kw):\n  super().__init__('start',*args,**kw)\n  \n def _complete(self,kind,*args,text=None ,multiline=False ):\n  self.kind=kind\n  self.args=args\n  self.text=text.strip()if text else None\n  self.multiline=multiline\n  \n def _finish_multiline(self,kind,*args):\n  return self._finish(kind,*args,multiline=True )\n  \n def _finish(self,kind,*args,**kw):\n  args=list(args)\n  nargs=[]\n  while args:\n   a=args.pop(0)\n   if a ==':':\n    break\n    \n   nargs.append(a)\n   \n  if args:\n   text=args[0]\n  else :\n   text=None\n  return self._complete(kind,*nargs,text=text,**kw)\n  \n @property\n def left(self):\n  return self.kind\n  \n @property\n def right(self):\n  return self.text\n  \n def __repr__(self):\n  return f'SequenceItem: {self.left}'\n  \n def dumps(self):\n  f=StringIO()\n  f.write(self.left)\n  \n  if self.right:\n   f.write(': ')\n   if self.multiline:\n    f.write('|\\n')\n    for line in self.right.splitlines():\n     f.write(f'  {line}\\n')\n   else :\n    f.write(f'{self.right}')\n    \n  return f.getvalue()\n  \n statemap={\n 'start':{\n NAME:Goto(nextstate='name'),\n },\n 'name':{\n NAME:Goto(nextstate='name'),\n TILDA:Goto(nextstate='name'),\n NEWLINE:FinalConsume(_finish,alltokens=True ),\n COLON:Goto(nextstate=':'),\n },\n ':':{\n MULTILINE:FinalConsume(_finish_multiline,alltokens=True ),\n EVERYTHING:{\n NEWLINE:FinalConsume(_finish,alltokens=True )\n }\n },\n }\n \n \nclass Note(Item):\n multiline=False\n \n @LazyAttribute\n def modules(self):\n  result=[]\n  for m in self.args:\n   if m =='~':\n    continue\n   result.append(m)\n   \n  return result\n  \n @LazyAttribute\n def left(self):\n  result=self.kind\n  \n  if self.args:\n   result +=f'{\" \".join(self.args)}'\n   \n  return result\n  \n def _finish(self,*args,**kw):\n  super()._finish('@',*args,**kw)\n  \n statemap={\n 'start':{NAME:{\n TILDA:{\n COLON:Goto(nextstate=':'),\n NAME:{\n COLON:Goto(nextstate=':'),\n },\n },\n COLON:Goto(nextstate=':'),\n }},\n ':':{\n MULTILINE:FinalConsume(Item._finish_multiline,alltokens=True ),\n EVERYTHING:{\n NEWLINE:FinalConsume(_finish,alltokens=True )\n }\n },\n }\n \n \nclass ContainerItem(Item,Container):\n\n def dumps(self):\n  f=StringIO()\n  f.write(super().dumps())\n  \n  if len(self):\n   f.write('\\n')\n   for c in self:\n    for line in c.dumps().splitlines():\n     f.write(f'  {line}\\n')\n     \n  return f.getvalue().rstrip('\\n')\n  \n  \nclass Call(ContainerItem):\n caller=None\n callee=None\n returntext=None\n returnsign='->'\n \n @LazyAttribute\n def left(self):\n  return f'{self.caller} -> {self.callee}'\n  \n @LazyAttribute\n def right(self):\n  if not self.text:\n   return\n   \n  f=StringIO()\n  f.write(self.text)\n  if self.returntext:\n   f.write(f' {self.returnsign} {self.returntext}')\n   \n  return f.getvalue()\n  \n def _complete(self,caller,callee,text=None ):\n  self.caller=caller\n  self.callee=callee\n  if text and self.returnsign in text:\n   text,returntext=text.rsplit(self.returnsign,1)\n   self.returntext=returntext.strip()\n  super()._complete('call',text=text)\n  \n statemap={\n 'start':{NAME:{RARROW:{NAME:Goto(nextstate='name -> name')}}},\n 'name -> name':{\n NEWLINE:FinalConsume(_complete),\n EOF:FinalConsume(_complete),\n COLON:Goto(nextstate=':'),\n },\n ':':{EVERYTHING:{\n NEWLINE:FinalConsume(_complete)\n }}\n }\n \n \nclass Loop(ContainerItem):\n pass\n \n \nclass Condition(ContainerItem):\n pass\n \n \nclass SequenceDiagram(Interpreter,Container):\n ''\n\n\n\n\n \n title='Untitled Sequence Diagram'\n description=None\n tags=None\n \n def __init__(self,*args,**kwargs):\n  super().__init__('title',*args,**kwargs)\n  self.modules={}\n  self.modules_order=[]\n  self._callstack=[]\n  \n def __repr__(self):\n  return f'SequenceDiagram: {self.title}'\n  \n def dumps(self):\n  f=StringIO()\n  f.write('sequence:')\n  \n  if self.title:\n   f.write(f' {self.title}')\n   \n  f.write('\\n')\n  \n  if self.description:\n   f.write(f'description: {self.description}\\n')\n   \n  if self.tags:\n   f.write(f'tags: {self.tags}\\n')\n   \n  modattrs=[]\n  for k,v in sorted(self.modules.items()):\n   if k !=v.title:\n    modattrs.append((k,'title',v.title))\n    \n   if 'module'!=v.type:\n    modattrs.append((k,'type',v.type))\n    \n  if modattrs:\n   f.write('\\n# Modules\\n')\n   for m,a,v in modattrs:\n    f.write(f'{m}.{a}: {v}\\n')\n    \n  if len(self):\n   f.write('\\n')\n   for c in self:\n    f.write(f'{c.dumps()}\\n')\n    \n  return f.getvalue()\n  \n def _ensuremodule(self,name,visible=False ):\n  if name not in self.modules:\n   self.modules[name]=Module(name)\n   \n  if visible and name not in self.modules_order:\n   self.modules_order.append(name)\n   \n @property\n def current(self):\n  if self._callstack:\n   return self._callstack[-1]\n   \n  return self\n  \n def _indent(self):\n  if len(self.current):\n   self._callstack.append(self.current[-1])\n   \n def _dedent(self):\n  if self._callstack:\n   self._callstack.pop()\n   \n def _new_call(self,call):\n  self._ensuremodule(call.caller,visible=True )\n  self._ensuremodule(call.callee,visible=True )\n  self.current.append(call)\n  \n def _new_note(self,note):\n  for m in note.modules:\n   self._ensuremodule(m,visible=False )\n   \n  self.current.append(note)\n  \n def _new_loop(self,loop):\n  self.current.append(loop)\n  \n def _new_condition(self,condition):\n  self.current.append(condition)\n  \n def _attr(self,attr,value):\n  value=value.strip()\n  \n  if attr =='description':\n   self.description=value\n  elif attr =='tags':\n   self.tags=value\n  else :\n   raise AttributeError(attr)\n   \n def _set_title(self,value):\n  self.title=value.strip()\n  \n def _module_attr(self,module,attr,value):\n  if not hasattr(Module,attr):\n   raise AttributeError(module,attr)\n   \n  self._ensuremodule(module)\n  setattr(self.modules[module],attr,value.strip())\n  \n _keywords={\n 'sequence':Final(nextstate='sequence'),\n 'state':Final(nextstate='start'),\n 'class':Final(nextstate='start'),\n 'for':New(Loop,callback=_new_loop,nextstate='start'),\n 'while':New(Loop,callback=_new_loop,nextstate='start'),\n 'loop':New(Loop,callback=_new_loop,nextstate='start'),\n 'if':New(Condition,callback=_new_condition,nextstate='start'),\n 'alt':New(Condition,callback=_new_condition,nextstate='start'),\n 'elif':New(Condition,callback=_new_condition,nextstate='start'),\n 'else':New(Condition,callback=_new_condition,nextstate='start'),\n }\n \n statemap={\n 'title':{\n EVERYTHING:{\n NEWLINE:Consume(_set_title,nextstate='start')\n }\n },\n 'start':{\n HASH:{EVERYTHING:{NEWLINE:Ignore(nextstate='start')}},\n NEWLINE:Ignore(nextstate='start'),\n INDENT:Ignore(callback=_indent,nextstate='indent'),\n DEDENT:Ignore(callback=_dedent,nextstate='start'),\n EOF:Final(nextstate='start'),\n NAME:Switch(default=Goto(nextstate='name'),**_keywords),\n AT:Ignore(nextstate='@'),\n },\n 'indent':{\n HASH:{EVERYTHING:{NEWLINE:Ignore(nextstate='start')}},\n NAME:Switch(default=Goto(nextstate='  name'),**_keywords),\n AT:Ignore(nextstate='@'),\n NEWLINE:Ignore(nextstate='start'),\n },\n 'name':{\n RARROW:New(Call,callback=_new_call,nextstate='start'),\n COLON:Goto(nextstate='attr:'),\n DOT:{NAME:{COLON:Goto(nextstate='mod.attr:')}},\n },\n '  name':{\n RARROW:New(Call,callback=_new_call,nextstate='start')\n },\n 'attr:':{\n EVERYTHING:{NEWLINE:Consume(_attr,nextstate='start')}\n },\n 'mod.attr:':{\n EVERYTHING:{NEWLINE:Consume(_module_attr,nextstate='start')}\n },\n '@':{\n NAME:New(Note,callback=_new_note,nextstate='start'),\n }\n }\n", ["adia.container", "adia.interpreter", "adia.lazyattr", "adia.token", "io"]], "adia": [".py", "''\n\n\n\n\nimport sys\n\nfrom .diagram import Diagram\nfrom .sequence import SequenceDiagram\nfrom .exceptions import InterpreterError,BadAttribute,BadSyntax\nfrom .renderer import Renderer\n\n\n__version__='0.4.0'\n__all__=[\n'Diagram',\n'SequenceDiagram',\n'InterpreterError',\n'BadAttribute',\n'BadSyntax',\n'Renderer',\n'print',\n'diagram'\n]\n\n\ndef diagram(source,rstrip=True ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return Diagram(source).renders(rstrip)\n \n \ndef print(source,file=None ,rstrip=True ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n Diagram(source).render(file or sys.stdout,rstrip)\n", ["adia.diagram", "adia.exceptions", "adia.renderer", "adia.sequence", "sys"], 1], "adia.exceptions": [".py", "from .token import TOKEN_NAMES,NEWLINE,EOF,INDENT,DEDENT,MULTILINE,\\\nEVERYTHING\n\n\nclass InterpreterError(Exception):\n def __init__(self,interpreter,token,msg):\n  filename=interpreter.tokenizer.filename or 'String'\n  \n  super().__init__(\n  f'{self.__class__.__name__}: '\n  f'File \"{filename}\", '\n  f'Interpreter: {interpreter.__class__.__name__}, '\n  f'line {token.start[0]}, col {token.start[1]}\\n'\n  f'{msg}'\n  )\n  \n  \nclass BadAttribute(InterpreterError):\n def __init__(self,interpreter,token,attr):\n  super().__init__(interpreter,token,f'Invalid attribute: {attr}.')\n  \n  \nclass BadSyntax(InterpreterError):\n def __init__(self,interpreter,token,expected=None ):\n  if token.type in [NEWLINE,EOF,INDENT,DEDENT,MULTILINE,EVERYTHING]:\n   got=TOKEN_NAMES[token.type]\n  else :\n   got=token.string\n   \n  if len(expected)>1:\n   expected=f'Expected one of `{\" \".join(expected)}`'\n  elif len(expected)==1:\n   expected=f'Expected `{expected[0]}`'\n   \n  super().__init__(\n  interpreter,token,f'{expected}, got: `{got}`.'\n  )\n", ["adia.token"]], "adia.constants": [".py", "LEFT=0\nRIGHT=1\n", []], "adia.tokenizer": [".py", "import re\n\nfrom .token import Token,EXACT_TOKENS,NEWLINE,PIPE,NAME,MULTILINE,\\\nEVERYTHING,DEDENT,INDENT,EOF\n\n\n\nWHITESPACE_RE=r' +'\nNAME_RE=r'\\w+'\nNEWLINE_RE=re.escape('\\n')\nALLTOKENS_RE=\\\n[re.escape(i[0])for i in EXACT_TOKENS]+\\\n[WHITESPACE_RE,NAME_RE,NEWLINE_RE]\nALLTOKENS_RE=re.compile('('+'|'.join(ALLTOKENS_RE)+')')\nTOKENS_DICT={t:n for t,n in EXACT_TOKENS}\n\n\nclass Tokenizer:\n def __init__(self):\n  self.filename=None\n  self.lineno=0\n  self.coloffset=-1\n  self.indentsize=0\n  self.indent=0\n  self.escape=False\n  self.newline=True\n  \n  \n  self._multiline=False\n  self._multiline_matching=[]\n  self._multiline_indent=False\n  self._multiline_lastlen=0\n  self._multiline_token=None\n  \n def _token(self,type_,string,start,end,line):\n  return Token(\n  type_,\n  string,\n  (self.lineno,start),\n  (self.lineno,end),\n  line\n  )\n  \n def _eoftoken(self,line):\n  return Token(EOF,'',(self.lineno,0),(self.lineno,0),'')\n  \n def _indenttoken(self,token,start,end,line):\n  return Token(\n  INDENT,\n  token[self.coloffset:],\n  (self.lineno,start+self.coloffset),\n  (self.lineno,end),\n  line\n  )\n  \n def _dedenttoken(self,lineindent,line):\n  return Token(\n  DEDENT,'',\n  (self.lineno,lineindent *self.indentsize+self.coloffset),\n  (self.lineno,lineindent *self.indentsize+self.coloffset),\n  line\n  )\n  \n def _newlinetoken(self,token,start,end,line):\n  return Token(\n  NEWLINE,\n  token,\n  (self.lineno,start),\n  (self.lineno,end),\n  line\n  )\n  \n def _everything(self,start,line):\n  end=len(line)\n  value=line[start:-1]\n  \n  yield Token(\n  EVERYTHING,\n  value,\n  (self.lineno,start),\n  (self.lineno,end -1),\n  line\n  )\n  \n  yield self._newlinetoken(line[-1],end -1,end,line)\n  \n def _tokenizeline(self,line):\n  self.lineno +=1\n  \n  if self._multiline:\n   m=re.match(WHITESPACE_RE,line)\n   end=m.span()[1]if m else 0\n   if self._multiline_indent ==0 and end >0:\n    self._multiline_indent=end\n    self._multiline_token=line[self._multiline_indent:]\n    self._multiline_lastlen=len(line)\n    return\n   elif end <self._multiline_indent:\n    sl=self._multiline_matching[-1].start[0]\n    self._multiline_matching.clear()\n    yield Token(\n    MULTILINE,\n    self._multiline_token[:-1],\n    (sl+1,self._multiline_indent),\n    (self.lineno -1,self._multiline_lastlen -1),\n    line\n    )\n    self._multiline=False\n    self._multiline_indent=0\n   elif end >0:\n    self._multiline_token +=line[self._multiline_indent:]\n    self._multiline_lastlen=len(line)\n    return\n    \n  if line =='':\n   yield self._eoftoken(line)\n   return\n   \n  for m in ALLTOKENS_RE.finditer(line):\n   token=m.group()\n   start,end=m.span()\n   \n   if token =='\\\\':\n    if self.escape:\n     self.escape=False\n    else :\n     self.escape=True\n     continue\n   elif self.escape:\n    self.escape=False\n    if token !='\\n':\n     yield self._token(NAME,token,start,end,line)\n     \n    continue\n    \n   if self.newline and (start ==0):\n    lineindent=0\n    if token.startswith(' '):\n    \n     if self.coloffset <0:\n      self.coloffset=end\n      \n     elif not self.indentsize:\n      self.indentsize=end -self.coloffset\n      \n     if self.indentsize and (end >self.coloffset):\n      lineindent=(end -self.coloffset)//self.indentsize\n      \n    elif token not in ['\\n']and self.coloffset <0:\n     self.coloffset=start\n     \n    if lineindent >self.indent:\n     self.indent=lineindent\n     yield self._indenttoken(token,start,end,line)\n     \n    elif lineindent <self.indent:\n     for i in range(self.indent -lineindent):\n      self.indent -=1\n      yield self._dedenttoken(lineindent,line)\n      \n   if token.startswith(' '):\n   \n    continue\n    \n   self.newline=token =='\\n'\n   if self.newline:\n    yield self._newlinetoken(token,start,end,line)\n    continue\n    \n   yield self._token(\n   TOKENS_DICT.get(token,NAME),\n   token,\n   start,\n   end,\n   line\n   )\n   \n   if token in (':','#'):\n    if line[end]==' ':\n     end +=1\n    if line[end]!='|':\n     yield from self._everything(start+1,line)\n     self.newline=True\n     return\n     \n def feedline(self,line):\n  for token in self._tokenizeline(line):\n   if token.type ==PIPE:\n    self._multiline_matching.append(token)\n    continue\n   elif token.type ==NEWLINE and len(self._multiline_matching)==1:\n    self._multiline_matching.append(token)\n    self._multiline=True\n    continue\n   else :\n    while self._multiline_matching:\n     yield self._multiline_matching.pop(0)\n    yield token\n", ["adia.token", "re"]], "adia.interpreter": [".py", "import abc\n\nfrom .token import TOKEN_NAMES,EXACT_TOKENS_DICT,MULTILINE,EVERYTHING,\\\nNAME\nfrom .tokenizer import Tokenizer\nfrom .exceptions import BadSyntax,BadAttribute\n\n\nclass Action:\n def __init__(self,nextstate=None ):\n  self.nextstate=nextstate\n  \n def __call__(self,interpreter,token):\n  return self.nextstate\n  \n  \nclass Switch(Action):\n def __init__(self,default=None ,**kw):\n  self.default=default\n  self.cases={k.rstrip('_'):v for k,v in kw.items()}\n  super().__init__()\n  \n def __call__(self,interpreter,token,*args):\n  action=self.cases.get(token.string,self.default)\n  if action is None :\n   raise BadSyntax(interpreter,token,expected=self.cases.keys())\n   \n  return action(interpreter,token,*args)\n  \n  \nclass Goto(Action):\n def __init__(self,callback=None ,nextstate=None ):\n  self.callback=callback\n  super().__init__(nextstate)\n  \n def _call_callback(self,interpreter,token,*args,**kw):\n  if self.callback is None :\n   return\n   \n  try :\n   self.callback(interpreter,*args,**kw)\n  except AttributeError as e:\n   raise BadAttribute(interpreter,token,'.'.join(e.args))\n   \n def __call__(self,interpreter,token,*args):\n  self._call_callback(interpreter,token,*args)\n  return super().__call__(interpreter,token)\n  \n  \nclass Consume(Goto):\n limit=[\n NAME,\n EVERYTHING,\n MULTILINE,\n ]\n \n def __init__(self,callback=None ,nextstate=None ,alltokens=False ):\n  if alltokens:\n   self.limit=None\n   \n  super().__init__(callback=callback,nextstate=nextstate)\n  \n def __call__(self,interpreter,token,*args):\n  args=tuple(\n  i.string for i in interpreter.tokenstack if\n  not self.limit or i.type in self.limit\n  )\n  interpreter.tokenstack.clear()\n  return super().__call__(interpreter,token,*args)\n  \n  \nclass Ignore(Consume):\n def __call__(self,interpreter,token):\n  interpreter.tokenstack.clear()\n  return super().__call__(interpreter,token)\n  \n  \nclass Final(Action):\n def __call__(self,interpreter,*args,**kw):\n  interpreter.more=False\n  return super().__call__(interpreter,*args,**kw)\n  \n  \nclass FinalConsume(Consume):\n def __call__(self,interpreter,*args,**kw):\n  interpreter.more=False\n  return super().__call__(interpreter,*args,**kw)\n  \n  \nclass New(Consume):\n target=None\n parent=None\n \n def __init__(self,factory,*args,**kwargs):\n  self.factory=factory\n  super().__init__(*args,**kwargs)\n  \n def __call__(self,parent,token):\n  self.target=self.factory(tokenizer=parent.tokenizer)\n  self.parent=parent\n  \n  while parent.tokenstack:\n   self.eat_token(parent.tokenstack.pop(0))\n   \n  return self\n  \n def eat_token(self,token):\n  more,nextstate=self.target.eat_token(token)\n  if more:\n   return None\n   \n  self._call_callback(self.parent,token,self.target)\n  \n  return self.nextstate or nextstate\n  \n  \nclass Interpreter(metaclass=abc.ABCMeta):\n def __init__(self,initialstate,*args,tokenizer=None ,**kwargs):\n  super().__init__(*args,**kwargs)\n  self.tokenizer=tokenizer if tokenizer else Tokenizer()\n  self.more=True\n  self.state=self.statemap[initialstate]\n  self.tokenstack=[]\n  \n @property\n @abc.abstractmethod\n def statemap(self):\n  raise NotImplementedError()\n  \n def _set_state(self,key):\n  if isinstance(key,str):\n   self.state=self.statemap[key]\n  else :\n   self.state=key\n   \n def _redirect(self,target,token):\n  newstatekey=target.eat_token(token)\n  if newstatekey is not None :\n   self._set_state(newstatekey)\n   \n def eat_token(self,token):\n  if isinstance(self.state,New):\n   self._redirect(self.state,token)\n   return self.more,None\n   \n  try :\n   newstate=self.state[token.type]\n  except KeyError:\n   validtokens=[\n   EXACT_TOKENS_DICT.get(i,TOKEN_NAMES[i])\n   for i in self.state.keys()\n   ]\n   raise BadSyntax(self,token,expected=validtokens)\n   \n  self.tokenstack.append(token)\n  \n  if callable(newstate):\n   newstate=newstate(self,token)\n   \n  if not self.more:\n   return self.more,newstate\n   \n  self._set_state(newstate)\n  return True ,None\n", ["abc", "adia.exceptions", "adia.token", "adia.tokenizer"]], "adia.token": [".py", "from collections import namedtuple\n\n\n__all__=[]\n\n\nEOF=0\nNAME=1\nNEWLINE=2\nAT=3\nDOT=4\nCOLON=5\nRARROW=9\nINDENT=10\nDEDENT=11\nBACKSLASH=12\nPIPE=14\nHASH=15\nMULTILINE=16\nEVERYTHING=17\nTILDA=18\n\n\nTOKEN_NAMES={\nvalue:name for name,value in globals().items()\nif isinstance(value,int)and not name.startswith('_')\n}\n\n\n__all__.extend(TOKEN_NAMES.values())\n\n\nEXACT_TOKENS=[\n('->',RARROW),\n('@',AT),\n(':',COLON),\n('\\\\',BACKSLASH),\n('|',PIPE),\n('~',TILDA),\n('#',HASH),\n('.',DOT),\n]\nEXACT_TOKENS_DICT={value:string for string,value in EXACT_TOKENS}\n\n\n\nclass Token(namedtuple('Token','type string start end line')):\n def __repr__(self):\n  return f'Token({TOKEN_NAMES[self.type]}, {self.string}, '\\\n  f'{self.start}, {self.end}, {self.line})'\n", ["collections"]], "adia.mutablestring": [".py", "class MutableString:\n ''\n \n def __init__(self,initial):\n  self._backend=[]\n  \n  if isinstance(initial,str):\n   self +=initial\n  else :\n   self.extendright(initial)\n   \n def __iadd__(self,new):\n  self._backend.extend(new)\n  return self\n  \n def __len__(self):\n  return self._backend.__len__()\n  \n def __eq__(self,other):\n  if isinstance(other,str):\n   return self.__str__()==other\n   \n  return self._backend ==other\n  \n def __ne__(self,other):\n  if isinstance(other,str):\n   return self.__str__()!=other\n   \n  return self._backend !=other\n  \n def __str__(self):\n  return ''.join(self._backend)\n  \n def __repr__(self):\n  return f'\\'{self.__str__()}\\''\n  \n def __getitem__(self,s):\n  return ''.join(self._backend.__getitem__(s))\n  \n def __setitem__(self,s,value):\n  if isinstance(s,slice):\n   vlen=len(value)\n   stop=s.start+vlen\n   if s.stop is None :\n    s=slice(s.start,stop)\n    \n   elif s.stop >vlen:\n    raise ValueError(\n    f'attempt to assign sequence of size {vlen} to replace '\n    f'with slice of size {s.stop - s.start}'\n    )\n  return self._backend.__setitem__(s,value)\n  \n def __delitem__(self,s):\n  self._backend.__delitem__(s)\n  \n def reverse(self):\n  self._backend.reverse()\n  \n def insert(self,index,s):\n  for i in s[::-1]:\n   self._backend.insert(index,i)\n   \n def extendright(self,size):\n  self._backend.extend(' '*size)\n  \n def extendleft(self,size):\n  while size:\n   self._backend.insert(0,' ')\n   size -=1\n   \n def _trim(self,size,index=-1):\n  while size:\n   self._backend.pop(index)\n   size -=1\n   \n def trimstart(self,size):\n  self._trim(size,index=0)\n  \n def trimend(self,size):\n  self._trim(size)\n", []], "adia.canvas": [".py", "from .mutablestring import MutableString\n\n\nclass Canvas:\n\n def __init__(self,size=(0,0)):\n  self._backend=[]\n  self.cols=size[0]\n  self.rows=0\n  self.extendbottom(size[1])\n  \n def __iter__(self):\n  for line in self._backend:\n   yield line\n   \n @property\n def size(self):\n  return self.cols,self.rows\n  \n def extendright(self,addcols):\n  assert addcols >=0\n  for r in self._backend:\n   r.extendright(addcols)\n   \n  self.cols +=addcols\n  \n def extendleft(self,addcols):\n  assert addcols >=0\n  for r in self._backend:\n   r.extendleft(addcols)\n   \n  self.cols +=addcols\n  \n def extendbottom(self,addrows):\n  assert addrows >=0\n  for i in range(addrows):\n   self._backend.append(MutableString(self.cols))\n   \n  self.rows +=addrows\n  \n def extendtop(self,addrows):\n  assert addrows >=0\n  for i in range(addrows):\n   self._backend.insert(0,MutableString(self.cols))\n   \n  self.rows +=addrows\n  \n def __str__(self):\n  return '\\n'.join(str(line)for line in self._backend)+'\\n'\n  \n def set_char(self,col,row,char):\n  if col >=self.cols:\n   self.extendright((col+1)-self.cols)\n   \n  if row >=self.rows:\n   self.extendbottom((row+1)-self.rows)\n   \n  self._backend[row][col]=char\n  \n def draw_vline(self,col,startrow,length,char='|'):\n  for r in range(startrow,startrow+length):\n   self.set_char(col,r,char)\n   \n def write_textline(self,col,row,line):\n  for c in line:\n   self.set_char(col,row,c)\n   col +=1\n   \n def write_hcenter(self,col,row,text,width=None ):\n  tlen=len(text)\n  if tlen >self.cols:\n   self.extendright(tlen -self.cols)\n   \n  col=col+(width or self.cols)//2 -tlen //2\n  self.write_textline(col,row,text)\n  \n def draw_hline(self,col,row,length,text=None ,texttop=None ,\n textbottom=None ,char='-'):\n  for c in range(col,col+length):\n   self.set_char(c,row,char)\n   \n  if text:\n   self.write_hcenter(col,row,text,length)\n   \n  if texttop:\n   self.write_hcenter(col,row -1,texttop,length)\n   \n  if textbottom:\n   self.write_hcenter(col,row+1,textbottom,length)\n   \n def draw_box(self,col,row,width,height,hlinechar='-',vlinechar='|',\n cornerchar='+'):\n  lastrow=row+height -1\n  lastcol=col+width -1\n  hline_start=col+1\n  hline_end=width -2\n  vline_start=row+1\n  vline_end=height -2\n  \n  self.draw_hline(hline_start,row,hline_end,char=hlinechar)\n  self.draw_hline(hline_start,lastrow,hline_end,char=hlinechar)\n  self.draw_vline(col,vline_start,vline_end,char=vlinechar)\n  self.draw_vline(lastcol,vline_start,vline_end,char=vlinechar)\n  self.set_char(col,row,cornerchar)\n  self.set_char(col+width -1,row,cornerchar)\n  self.set_char(col,row+height -1,cornerchar)\n  self.set_char(col+width -1,row+height -1,cornerchar)\n  \n def write_textblock(self,col,row,text):\n  for line in text.splitlines():\n   self.write_textline(col,row,line)\n   row +=1\n   \n def draw_textbox(self,col,row,text,mincols=0,hpadding=0,vpadding=0,\n **kw):\n  lines=text.splitlines()\n  textheight=len(lines)\n  width=max(mincols,max(len(line)for line in lines))\n  \n  if not isinstance(hpadding,int):\n   lpad,rpad=hpadding\n  else :\n   lpad=rpad=hpadding\n   \n  boxheight=textheight+(vpadding *2)+2\n  boxwidth=width+lpad+rpad+2\n  self.write_textblock(col+lpad+1,row+vpadding+1,text)\n  self.draw_box(col,row,boxwidth,boxheight,**kw)\n  \n def draw_rightarrow(self,col,row,length,**kw):\n  self.draw_hline(col,row,length -1,**kw)\n  self.set_char(col+length -1,row,'>')\n  \n def draw_leftarrow(self,col,row,length,**kw):\n  self.draw_hline(col+1,row,length -1,**kw)\n  self.set_char(col,row,'<')\n  \n def draw_toparrow(self,col,row,length,**kw):\n  self.draw_vline(col,row+1,length -1,**kw)\n  self.set_char(col,row,'^')\n  \n def draw_bottomarrow(self,col,row,length,**kw):\n  self.draw_vline(col,row,length -1,**kw)\n  self.set_char(col,row+length -1,'v')\n", ["adia.mutablestring"]], "adia.lazyattr": [".py", "''\n\n\nclass LazyAttribute:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __slots__=('_factory',)\n \n def __init__(self,factory):\n  self._factory=factory\n  \n def __get__(self,obj,owner=None ):\n  factory=self._factory\n  if obj is None :\n   return factory\n  val=factory(obj)\n  setattr(obj,factory.__name__,val)\n  return val\n", []], "adia.renderer": [".py", "import io\nimport itertools\n\nfrom .sequence import SequenceDiagram,Call,Condition,Loop,Note\nfrom .canvas import Canvas\nfrom .constants import LEFT,RIGHT\nfrom .renderingplans import ModulePlan,ItemStartPlan,ItemEndPlan,\\\nConditionStartPlan,ConditionEndPlan,NotePlan\n\n\ndef twiniter(items):\n if not hasattr(items,'__next__'):\n  items=iter(items)\n  \n f=None\n try :\n  f=next(items)\n  while True :\n   n=next(items)\n   yield f,n\n   f=n\n except StopIteration:\n  yield f,None\n  \n  \nclass Renderer:\n def __init__(self,diagram,canvas=None ):\n  self._repeats=set()\n  self.diagram=diagram\n  \n  if canvas is None :\n   self.canvas=Canvas()\n  else :\n   self.canvas=canvas\n   \n def register_repeat(self,col,char):\n  self._repeats.add((col,char))\n  \n def unregister_repeat(self,col,char):\n  self._repeats.remove((col,char))\n  \n def _render_emptyline(self):\n  for col,char in self._repeats:\n   self.canvas.set_char(col,self.row,char)\n   \n def _extend(self,i):\n  self.canvas.extendbottom(i)\n  \n @property\n def row(self):\n  return self.canvas.rows -1\n  \n def _render_header(self):\n  dia=self.diagram\n  self._extend(1)\n  self.canvas.write_textline(0,self.row,f'DIAGRAM: {dia.title}')\n  \n  if dia.author:\n   self._extend(1)\n   self.canvas.write_textline(0,self.row,f'author: {dia.author}')\n   \n  if dia.version:\n   self._extend(1)\n   self.canvas.write_textline(0,self.row,f'version: {dia.version}')\n   \n def render(self):\n  self._render_header()\n  \n  for unit in self.diagram:\n   if isinstance(unit,SequenceDiagram):\n    SequenceRenderer(unit,self.canvas).render()\n    \n def _dumplines(self,rstrip):\n  for line in self.canvas:\n   line=str(line)\n   if rstrip:\n    line=line.rstrip()\n    \n   yield f'{line}\\n'\n   \n def dump(self,filelike,rstrip=True ):\n  self.render()\n  \n  for line in self._dumplines(rstrip):\n   filelike.write(line)\n   \n def dumps(self,rstrip=True ):\n  out=io.StringIO()\n  self.dump(out,rstrip)\n  \n  \n  return out.getvalue()[:-1]\n  \n  \nclass SequenceRenderer(Renderer):\n _moduleplans=None\n _moduleplans_dict=None\n _itemplans=None\n \n def _planmodules(self):\n  self._moduleplans=[]\n  self._moduleplans_dict={}\n  for m in self.diagram.modules_order:\n   module=ModulePlan(self.diagram.modules[m],lpad=1,rpad=1)\n   self._moduleplans.append(module)\n   self._moduleplans_dict[m]=module\n   \n  for k,v in self.diagram.modules.items():\n   if k not in self._moduleplans_dict:\n    module=ModulePlan(self.diagram.modules[k],lpad=1,rpad=1)\n    self._moduleplans.append(module)\n    self._moduleplans_dict[k]=module\n    \n  if self._moduleplans:\n   self._moduleplans[0].lpad=0\n   self._moduleplans[-1].rpad=0\n   \n def _fromto_modules(self,from_,to,reverse=False ):\n  capt=False\n  \n  it=self._moduleplans\n  if reverse:\n   it=reversed(it)\n   \n  for m,nm in twiniter(it):\n   if not capt and m is not from_:\n    continue\n    \n   if m is from_:\n    capt=True\n    \n   if capt:\n    if m is to:\n     yield m,None\n     return\n    yield m,nm\n    \n def _availspacefor_call(self,from_,to,reverse=False ):\n  result=0\n  for m,nm in self._fromto_modules(from_,to,reverse):\n   result +=m.boxlen\n   if nm is None :\n    continue\n    \n   if reverse:\n    result +=max(m.lpad,nm.rpad)\n   else :\n    result +=max(m.rpad,nm.lpad)\n    \n  if from_:\n   result -=from_.boxlen //2+1\n   \n  if to:\n   result -=to.boxlen //2+1\n   \n  result -=7\n  return 0 if result <0 else result\n  \n def _availspacefor_condition(self,from_,to):\n  result=0\n  for m,nm in self._fromto_modules(from_,to,False ):\n   if m is None :\n    break\n    \n   result +=m.boxlen\n   if nm is None :\n    continue\n    \n   result +=max(m.rpad,nm.lpad)\n   \n  result -=4\n  if result <0:\n   return 0\n   \n  return result\n  \n def _availspacefor_note(self,from_,to):\n  result=0\n  single=False\n  \n  if to is None :\n   single=True\n   try :\n    to=self._moduleplans[self._moduleplans.index(from_)+1]\n   except IndexError:\n    to=None\n    \n  if to is None :\n   result +=from_.boxlen\n  else :\n   for m,nm in self._fromto_modules(from_,to,False ):\n    result +=m.boxlen\n    if nm is None :\n     continue\n     \n    result +=max(m.rpad,nm.lpad)\n    \n  if single and to is not None :\n   result -=to.boxlen\n   \n  result -=4\n  \n  return result\n  \n def _find_condition_startend(self,children):\n  items=[(\n  self._moduleplans.index(i.caller),\n  self._moduleplans.index(i.callee))\n  for i in children if isinstance(i,ItemStartPlan)]\n  \n  items=sorted(list(set(itertools.chain(*items))))\n  start,end=items[0],items[-1]\n  return self._moduleplans[start],self._moduleplans[end],start,end\n  \n def _plancondition(self,item,level):\n  last,start,end=None ,None ,None\n  if self._itemplans:\n   last=self._itemplans[-1]\n   if isinstance(last,ConditionEndPlan)and\\\n   item.kind not in ('if','for','while'):\n    old=self._itemplans.pop()\n    start=old.startmodule\n    end=old.endmodule\n    \n  condstart_plan=ConditionStartPlan(item,start,end,level)\n  self._itemplans.append(condstart_plan)\n  \n  if len(item):\n   self._recurse(item,level+1)\n   \n  s=self._itemplans.index(condstart_plan)+1\n  if len(self._itemplans)>s:\n   start,end,si,ei=\\\n   self._find_condition_startend(self._itemplans[s:])\n   \n   for p in self._itemplans[s::-1]:\n    if p.level >level:\n     continue\n     \n    if p.startmodule is None :\n     p.startmodule=start\n    else :\n     mi=self._moduleplans.index(p.startmodule)\n     if mi >si:\n      p.startmodule=start\n     elif mi <si:\n      start=p.startmodule\n      \n    if p.endmodule is None :\n     p.endmodule=end\n    else :\n     mi=self._moduleplans.index(p.endmodule)\n     if mi <ei:\n      p.endmodule=end\n     elif mi >si:\n      end=p.endmodule\n      \n    if p.kind in ('if','for','while'):\n     break\n     \n  elif isinstance(last,(ItemStartPlan,ItemEndPlan)):\n   if start is None :\n    start=last.caller\n    condstart_plan.startmodule=start\n    \n   if end is None :\n    end=last.callee\n    condstart_plan.endmodule=end\n    \n  if start is not None and condstart_plan.singlemodule:\n   start.rpad=max(\n   start.rpad,\n   (condstart_plan.textwidth -start.boxlen)+4\n   )\n  else :\n   avail=self._availspacefor_condition(start,end)\n   if condstart_plan.textwidth >avail:\n    amount=condstart_plan.textwidth -avail\n    if start:\n     start.rpad +=amount\n     \n    if end:\n     end.lpad +=amount\n     \n  condend_plan=ConditionEndPlan(item,start,end,level)\n  self._itemplans.append(condend_plan)\n  \n  condstart_plan.children=self._itemplans\n  \n def _plannote(self,item,level):\n  modules=item.modules\n  start=self._moduleplans_dict[modules[0]]\n  if len(modules)>1:\n   end=self._moduleplans_dict[modules[1]]\n  else :\n   end=None\n   \n  noteplan=NotePlan(item,start,end,level)\n  self._itemplans.append(noteplan)\n  \n  avail=self._availspacefor_note(start,end)\n  if noteplan.textwidth >avail:\n   amount=noteplan.textwidth -avail\n   if start:\n    start.rpad +=amount\n    \n   if end:\n    end.lpad +=amount\n    \n def _calculate_callpaddings(self,itemplan,callee,caller,dir_):\n  if itemplan.selfcall:\n   callee.rpad=max(callee.rpad,itemplan.textwidth+3)\n  else :\n   avail=self._availspacefor_call(\n   caller,callee,reverse=dir_ ==LEFT\n   )\n   if itemplan.textwidth >avail:\n    amount=itemplan.textwidth -avail\n    if dir_ ==LEFT:\n     caller.lpad +=amount\n    else :\n     caller.rpad +=amount\n     \n def _plancall(self,item,level):\n  caller=self._moduleplans_dict[item.caller]\n  callee=self._moduleplans_dict[item.callee]\n  diff=self._moduleplans.index(callee)-\\\n  self._moduleplans.index(caller)\n  \n  dir_=LEFT if diff <0 else RIGHT\n  itemplan=ItemStartPlan(item,caller,callee,dir_,level)\n  self._itemplans.append(itemplan)\n  self._calculate_callpaddings(itemplan,callee,caller,dir_)\n  \n  if len(item):\n   self._recurse(item,level+1)\n   \n  itemplan=ItemEndPlan(item,caller,callee,not (dir_),level)\n  self._itemplans.append(itemplan)\n  \n  if itemplan.text:\n   self._calculate_callpaddings(itemplan,callee,caller,dir_)\n   \n def _recurse(self,parent,level):\n  for item in parent:\n   if isinstance(item,Call):\n    self._plancall(item,level)\n   elif isinstance(item,(Condition,Loop)):\n    self._plancondition(item,level)\n   elif isinstance(item,Note):\n    self._plannote(item,level)\n    \n def _planitems(self):\n  self._itemplans=[]\n  self._recurse(self.diagram,0)\n  \n def plan(self):\n  self._planmodules()\n  self._planitems()\n  \n  \n def _render_modules(self):\n  self._extend(1)\n  fm=self._moduleplans[0]\n  row=self.row\n  col=fm.lpad\n  \n  for m,nm in twiniter(self._moduleplans):\n   m.drawbox(self,col,row)\n   col +=m.boxlen+max(m.rpad,nm.lpad if nm else 0)\n   \n  if col >self.canvas.cols:\n   self.canvas.extendright(col -self.canvas.cols)\n   \n def _render_emptyline(self):\n  self._extend(1)\n  for m in self._moduleplans:\n   m.drawpipe(self,self.row)\n   \n  super()._render_emptyline()\n  \n def _render_emptylines(self,count=1):\n  for _ in range(count):\n   self._render_emptyline()\n   \n def _render_items(self):\n  lastdir=None\n  lasttype=None\n  \n  for c in self._itemplans:\n  \n   if lastdir is not None and (\n   c.direction !=lastdir\n   or not lasttype\n   or not isinstance(c,lasttype)):\n    self._render_emptylines()\n    \n    \n   lines_before,lines,lines_after=c.calc()\n   self._render_emptylines(lines_before+lines)\n   c.draw(self,self.row -(lines -1))\n   self._render_emptylines(lines_after)\n   \n   lastdir=c.direction\n   lasttype=type(c)\n   \n def render(self):\n  self.plan()\n  \n  \n  if self.diagram.title:\n   self._extend(3)\n   self.canvas.write_textline(\n   0,self.row,f'SEQUENCE: {self.diagram.title}')\n   \n  if self._moduleplans:\n   self._extend(1)\n   self._render_modules()\n   \n  if self._itemplans:\n   self._render_emptylines()\n   self._render_items()\n   \n  if self._moduleplans:\n   self._render_emptylines()\n   self._render_modules()\n", ["adia.canvas", "adia.constants", "adia.renderingplans", "adia.sequence", "io", "itertools"]], "adia.diagram": [".py", "from io import StringIO\n\nfrom .container import Container\nfrom .interpreter import Interpreter,Ignore,Switch,Goto,Consume,New\nfrom .sequence import SequenceDiagram\nfrom .token import NEWLINE,NAME,EVERYTHING,INDENT,EOF,HASH,COLON\nfrom .renderer import Renderer\n\n\nclass Diagram(Interpreter,Container):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n title='Untitled Diagram'\n version=None\n author=None\n \n def __init__(self,source=None ,*args,**kwargs):\n  super().__init__('start',*args,**kwargs)\n  if source is None :\n   return\n   \n  if isinstance(source,str):\n   self.parse(source)\n  else :\n   self.parsefile(source)\n   \n def __repr__(self):\n  return f'Diagram: {self.title}'\n  \n def dumps(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  f=StringIO()\n  f.write(f'diagram: {self.title}\\n')\n  \n  if self.version:\n   f.write(f'version: {self.version}\\n')\n   \n  if self.author:\n   f.write(f'author: {self.author}\\n')\n   \n  if len(self):\n   f.write('\\n')\n   for c in self:\n    f.write(f'{c.dumps()}')\n    \n  return f.getvalue()[:-1]\n  \n def parse(self,source):\n  ''\n\n\n\n  \n  with StringIO(source)as f:\n   self.parsefile(f)\n   \n def parsefile(self,sourcefile):\n  ''\n\n\n\n  \n  if hasattr(sourcefile,'name'):\n   self.tokenizer.filename=sourcefile.name\n   \n  while True :\n   line=sourcefile.readline()\n   self.parseline(line)\n   if not line:\n    return\n    \n def parseline(self,line):\n  ''\n\n\n\n  \n  if len(line)and not line.endswith('\\n'):\n   line +='\\n'\n   \n  for token in self.tokenizer.feedline(line):\n   self.eat_token(token)\n   \n  return\n  \n def render(self,outfile,rstrip=True ):\n  ''\n\n\n\n\n\n\n  \n  Renderer(self).dump(outfile,rstrip)\n  \n def renders(self,rstrip=True ):\n  ''\n\n\n\n\n\n\n  \n  return Renderer(self).dumps(rstrip)\n  \n def _set_title(self,attr,value):\n  self.title=value.strip()\n  \n def _attr(self,attr,value):\n  value=value.strip()\n  \n  if attr =='version':\n   self.version=value\n  elif attr =='author':\n   self.author=value\n   \n def _new_seq(self,sequence):\n  self.append(sequence)\n  \n _keywords={\n 'diagram':Goto(nextstate='title'),\n 'author':Goto(nextstate='attr'),\n 'version':Goto(nextstate='attr'),\n 'sequence':Goto(nextstate='sequence'),\n }\n \n statemap={\n 'start':{\n HASH:{EVERYTHING:{NEWLINE:Ignore(nextstate='start')}},\n INDENT:{NEWLINE:Ignore(nextstate='start')},\n NEWLINE:Ignore(nextstate='start'),\n EOF:Ignore(nextstate='start'),\n NAME:Switch(**_keywords),\n },\n 'title':{\n COLON:{EVERYTHING:{\n NEWLINE:Consume(_set_title,nextstate='start')\n }}\n },\n 'attr':{\n COLON:{\n EVERYTHING:{NEWLINE:Consume(_attr,nextstate='start')}\n },\n },\n 'sequence':{COLON:Ignore(nextstate='new-sequence')},\n 'new-sequence':{\n EVERYTHING:{\n NEWLINE:New(\n SequenceDiagram,\n callback=_new_seq,\n )\n }\n }\n }\n", ["adia.container", "adia.interpreter", "adia.renderer", "adia.sequence", "adia.token", "io"]], "adia.container": [".py", "class Container(list):\n def __init__(self,*args,**kwargs):\n  super().__init__(*args,**kwargs)\n", []]}
__BRYTHON__.update_VFS(scripts)
